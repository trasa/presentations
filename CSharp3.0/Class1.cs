using System;
using System.Collections.Generic;
using System.Linq;

namespace Blackfin.Cms.Web
{
    class Customer
    {
        #region #1 backing field - Auto-Implemented Properties
        // #1 backing field old way:
        private string customerId;

        public string CustomerId
        {
            get { return customerId; }
            set { customerId = value; }
        }

        // #1 new: exact same thing:
        public string CustomerId
        {
            // backing store is auto generated
            get;
            set;
        }

        // things to note:  get/set are generated by the compiler, turns into the code you'd expect,
        // this is just syntactic sugar.
        #endregion

        #region #1 (cont) create a few new properties

        public string ContactName { get; set; }
        public string City { get; set; }

        #endregion



    }

    public class Class1
    {
        // C# 3.0 goals:
        // Improve on C# 2.0 (particularly areas where theres a lot of repetition or boilerplate code)
        // implement LINQ
        // 100% backward compatible (so you can start using the new language features as you need to, don't have to do it all at once)



        static void Main(string[] args)
        {
            

            List<Customer> customers = LoadCustomers();
           
            #region Feature: Query Expressions (LINQ)
            var query = from c in customers 
                        where c.City == "London"
                        select c;
            
            // c# 2.0 alternative:
            List<Customer> result = new List<Customer>();
            foreach(Customer c in customers)
            {
                if (c.City == "London")
                    result.Add(c); // or in a method, using an iterator
            }

            // print results:
            // Note that "var" figures out that it is a Customer,
            // AND that we've got intellisense and strong-typing.  
            foreach(var item in query)
                Console.WriteLine("{0}, {1}, {2}", item.CustomerId, item.ContactName, item.City);

            // so why not just use the foreach + if?
            // - very easy to modify the queries over time, by adding simple pieces of code to the query
            // - example: ordering result by last name:
            var query = from c in customers 
                        where c.City == "London"
                        orderby c.ContactName.Split(' ')[1] // get the last name
                        select c;
            // note: this can take advantage of multicore processing, for free.

            #endregion

            #region feature: anonymous types
            // now, we only really need the name and id from the customer, so we don't need to build the whole
            // customer object:
            var query = from c in customers 
                        where c.City == "London"
                        orderby c.ContactName.Split(' ')[1] // get the last name
                        select new {CustomerID = c.CustomerID, ContactName = c.ContactName}
            ;
            // this constructs a new type, representing only these two properties:
            // again, these are strongly typed, type safe, etc.  fully fledged, but the type name has a 
            // generated name.  therefore you HAVE to use "var" to refer to the type.
            // also, var is limited to local methods, so you can't pass these types out to another class.
            // the public signature must still be explicit.
            
            // since this is a common pattern for anonymous types:
            var query = from c in customers 
                        where c.City == "London"
                        orderby c.ContactName.Split(' ')[1] // get the last name
                        select new {c.CustomerID, c.ContactName}
            // the CustomerID and ContactName properties will be inferred from the initializer

            #endregion


            // LINQ to Objects:
            // reimplement LINQ using only C# 3.0
            var query = Where(customers, c.City == "London"); // how do i pass this in as a function?
            // Lambda Expression
            var query = Where(customers, c => c.City == "London"); 
            // lambda:  
            // => indicates that it is a lambda
            // c: single argument to expr
            // exprs can also be explicitly typed
            // see WHERE expr: below
        }

        #region #2 method to create a list of customers
        private static List<Customer> LoadCustomers()
        {
            // d'oh, no ctor!
            //Customer c1 = new Customer();
            // much better: syntax initialize the properties (#2 object initializers)
            // new feature #2: Object Initializers
            //Customer c1 = new Customer() {CustomerId = "ALFKI", ContactName="Maria Anders", City="Berlin"};

            // feature#3 Collection Initializers
            // can create a list, but also want to initialize the list:
            List<Customer> customers =new List<Customer>()
            {
                cust1 // this initializes a collection 
            }

            #region #4 Combining Object Init and Collection Init
            // #4 - now, can combine Object Initializers and Collection Initializer:
            // these are general and can work 
            List<Customer> clist = new List<Customer>()
            {
                new Customer() { CustomerId = "ALFKI", ContactName="Maria Anders", City="Berlin"}
            };

            // initailze a dict:
            Dictionary<int, string> lookup = new Dictionary<int, string>()
            {
                // init by passing pairs
                { 1, "one"},
                { 2, "two")
            };
            #endregion

                // TODO snippet of Customer Objects (from other demos)
                return customers;

                #region simplify declarations

                // feature: "var" local variable type inference
                List<Customer> customers = new List<Customer>();
                // is same as:
                var customers = new List<Customer>(); // compiler fills in the values for the LHS - shorthand, but 
                // is still strongly typed and everything, see intellisense.  not loosely typed at all.

                customers = 1; // compile error!
                #endregion
            
        }
        #endregion

#region LINQ to Objects continued
            // returns the most general type of collection:

        public static IEnumerable<Customer> WHERE(List<Customer> source, Func filter)
        {
            // C# 2.0 - iterators : return multiple elements out of a body that returns ienumerable
            foreach(var item in source)
            {
                if (filter(item))
                    yield return item;
            }
                // need a delegate for the lambda: (C# 1.0 syntax)
        public delegate bool Func(Customer c);
        // another delegate:
        public delegate TResult Func<TResult>(Customer c)
            ;
    }

    // select method -- what should the return type be? need to be as general as possible:
    // also need a function to map elements from input (customer) to output (TResult)
    public static IEnumerable<TResult> SELECT<TResult>(List<Customer> source,  Func<TResult> selector)
    {
        foreach(var item in source)
            yield return selector(item);
    }
#endregion


    // more things to put together:
    // Extension Methods (this)
        // allows you to reimplement methods and override things using C#3.0 features
        // lambdas are the key to how this works (need defn of lambdas)

    //ExpressionTrees, Partial Methods -- used in making LINQ to SQL
    // Expr Tree - treat functions as data, functions can be inspected and manipulated (very general purpose, enables new kinds of APIs)
    // partial methods: extends partial types; allow code generators to emit code to a method which may or may not be implemented by a user
    //      if the method is not implemented, the code is just removed (removes negative performance impact, used extensively in WPF)

